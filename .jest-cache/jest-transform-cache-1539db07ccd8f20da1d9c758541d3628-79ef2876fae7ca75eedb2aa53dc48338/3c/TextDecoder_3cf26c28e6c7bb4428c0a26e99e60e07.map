{"version":3,"names":["inRange","a","min","max","codePointsToString","codePoints","s","i","length","cp","String","fromCharCode","normalizeBytes","input","ArrayBuffer","Uint8Array","buffer","byteOffset","byteLength","END_OF_STREAM","FINISHED","Stream","tokens","_classCallCheck2","default","Array","prototype","slice","call","reverse","_createClass2","key","value","endOfStream","read","pop","prepend","token","isArray","push","unshift","shift","decoderError","fatal","opt_code_point","TypeError","LABEL_ENCODING_MAP","getEncoding","label","trim","toLowerCase","ENCODING_MAP","encodings","labels","name","heading","forEach","category","encoding","DECODERS","UTF8","options","UTF8Decoder","utf8CodePoint","utf8BytesSeen","utf8BytesNeeded","utf8LowerBoundary","utf8UpperBoundary","handler","stream","bite","code_point","TextDecoder","exports","arguments","undefined","_BOMseen","_doNotFlush","_decoder","normalizedLabel","RangeError","Error","_encoding","_ignoreBOM","ignoreBOM","_errorMode","get","_this$_encoding$name$","_this$_encoding","decode","bytes","Boolean","input_stream","output","result","apply","_toConsumableArray2","serializeStream"],"sources":["TextDecoder.ts"],"sourcesContent":["// A fork of text-encoding but with only UTF-8 decoder.\n// `TextEncoder` is in Hermes and we only need utf-8 decoder for React Server Components.\n//\n// https://github.com/inexorabletash/text-encoding/blob/3f330964c0e97e1ed344c2a3e963f4598610a7ad/lib/encoding.js#L1\n\n/**\n * Checks if a number is within a specified range.\n * @param a The number to test.\n * @param min The minimum value in the range, inclusive.\n * @param max The maximum value in the range, inclusive.\n * @returns `true` if a passed number is within the specified range.\n */\nfunction inRange(a: number, min: number, max: number): boolean {\n  return min <= a && a <= max;\n}\n\n/**\n * Converts an array of code points to a string.\n * @param codePoints Array of code points.\n * @returns The string representation of given array.\n */\nfunction codePointsToString(codePoints: number[]): string {\n  let s = '';\n  for (let i = 0; i < codePoints.length; ++i) {\n    let cp = codePoints[i];\n    if (cp <= 0xffff) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n  return s;\n}\n\nfunction normalizeBytes(input?: ArrayBuffer | DataView): Uint8Array {\n  if (typeof input === 'object' && input instanceof ArrayBuffer) {\n    return new Uint8Array(input);\n  } else if (\n    typeof input === 'object' &&\n    'buffer' in input &&\n    input.buffer instanceof ArrayBuffer\n  ) {\n    return new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n  }\n  return new Uint8Array(0);\n}\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n */\nconst END_OF_STREAM = -1;\n\nconst FINISHED = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(number[]|Uint8Array)} tokens Array of tokens that provide the stream.\n */\nclass Stream {\n  private tokens: number[];\n\n  constructor(tokens: number[] | Uint8Array) {\n    this.tokens = Array.prototype.slice.call(tokens);\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse();\n  }\n\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream(): boolean {\n    return !this.tokens.length;\n  }\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n  read(): number {\n    if (!this.tokens.length) return END_OF_STREAM;\n    return this.tokens.pop()!;\n  }\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param token The token(s) to prepend to the stream.\n   */\n  prepend(token: number | number[]): void {\n    if (Array.isArray(token)) {\n      while (token.length) this.tokens.push(token.pop()!);\n    } else {\n      this.tokens.push(token);\n    }\n  }\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param token The tokens(s) to push to the stream.\n   */\n  push(token: number | number[]): void {\n    if (Array.isArray(token)) {\n      while (token.length) this.tokens.unshift(token.shift()!);\n    } else {\n      this.tokens.unshift(token);\n    }\n  }\n}\n\nfunction decoderError(fatal: boolean, opt_code_point?: number) {\n  if (fatal) throw TypeError('Decoder error');\n  return opt_code_point || 0xfffd;\n}\n\ninterface Encoding {\n  name: string;\n  labels: string[];\n}\n\nconst LABEL_ENCODING_MAP: { [key: string]: Encoding } = {};\n\nfunction getEncoding(label: string): Encoding | null {\n  label = label.trim().toLowerCase();\n  if (label in LABEL_ENCODING_MAP) {\n    return LABEL_ENCODING_MAP[label];\n  }\n  return null;\n}\n\n/** [Encodings table](https://encoding.spec.whatwg.org/encodings.json) (Incomplete as we only need TextDecoder utf8 in Expo RSC. A more complete implementation should be added to Hermes as native code.) */\nconst ENCODING_MAP: { heading: string; encodings: Encoding[] }[] = [\n  {\n    encodings: [\n      {\n        labels: [\n          'unicode-1-1-utf-8',\n          'unicode11utf8',\n          'unicode20utf8',\n          'utf-8',\n          'utf8',\n          'x-unicode20utf8',\n        ],\n        name: 'UTF-8',\n      },\n    ],\n    heading: 'The Encoding',\n  },\n];\n\nENCODING_MAP.forEach((category) => {\n  category.encodings.forEach((encoding) => {\n    encoding.labels.forEach((label) => {\n      LABEL_ENCODING_MAP[label] = encoding;\n    });\n  });\n});\n\n// Registry of of encoder/decoder factories, by encoding name.\nconst DECODERS: { [key: string]: (options: { fatal: boolean }) => UTF8Decoder } = {\n  'UTF-8': (options) => new UTF8Decoder(options),\n};\n\n// 9.1.1 utf-8 decoder\n\ninterface Decoder {\n  handler: (stream: Stream, bite: number) => number | number[] | null | -1;\n}\n\nclass UTF8Decoder implements Decoder {\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  private utf8CodePoint = 0;\n  private utf8BytesSeen = 0;\n  private utf8BytesNeeded = 0;\n  private utf8LowerBoundary = 0x80;\n  private utf8UpperBoundary = 0xbf;\n  constructor(private options: { fatal: boolean }) {}\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  handler(stream: Stream, bite: number): number | null | -1 {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === END_OF_STREAM && this.utf8BytesNeeded !== 0) {\n      this.utf8BytesNeeded = 0;\n      return decoderError(this.options.fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === END_OF_STREAM) return FINISHED;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (this.utf8BytesNeeded === 0) {\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      else if (inRange(bite, 0xc2, 0xdf)) {\n        // 1. Set utf-8 bytes needed to 1.\n        this.utf8BytesNeeded = 1;\n\n        // 2. Set UTF-8 code point to byte & 0x1F.\n        this.utf8CodePoint = bite & 0x1f;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xe0, 0xef)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xe0) this.utf8LowerBoundary = 0xa0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xed) this.utf8UpperBoundary = 0x9f;\n        // 3. Set utf-8 bytes needed to 2.\n        this.utf8BytesNeeded = 2;\n        // 4. Set UTF-8 code point to byte & 0xF.\n        this.utf8CodePoint = bite & 0xf;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xf0, 0xf4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xf0) this.utf8LowerBoundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xf4) this.utf8UpperBoundary = 0x8f;\n        // 3. Set utf-8 bytes needed to 3.\n        this.utf8BytesNeeded = 3;\n        // 4. Set UTF-8 code point to byte & 0x7.\n        this.utf8CodePoint = bite & 0x7;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(this.options.fatal);\n      }\n\n      // Return continue.\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, inclusive, run these substeps:\n    if (!inRange(bite, this.utf8LowerBoundary, this.utf8UpperBoundary)) {\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      this.utf8CodePoint = 0;\n      this.utf8BytesNeeded = 0;\n      this.utf8BytesSeen = 0;\n      this.utf8LowerBoundary = 0x80;\n      this.utf8UpperBoundary = 0xbf;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(this.options.fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    this.utf8LowerBoundary = 0x80;\n    this.utf8UpperBoundary = 0xbf;\n\n    // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n    // 0x3F)\n    this.utf8CodePoint = (this.utf8CodePoint << 6) | (bite & 0x3f);\n\n    // 7. Increase utf-8 bytes seen by one.\n    this.utf8BytesSeen += 1;\n\n    // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (this.utf8BytesSeen !== this.utf8BytesNeeded) return null;\n\n    // 9. Let code point be utf-8 code point.\n    const code_point = this.utf8CodePoint;\n\n    // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    this.utf8CodePoint = 0;\n    this.utf8BytesNeeded = 0;\n    this.utf8BytesSeen = 0;\n\n    // 11. Return a code point whose value is code point.\n    return code_point;\n  }\n}\n\n// 8.1 Interface TextDecoder\n// @docsMissing\nexport class TextDecoder {\n  private _encoding: Encoding | null;\n  private _ignoreBOM: boolean;\n  private _errorMode: string;\n  private _BOMseen: boolean = false;\n  private _doNotFlush: boolean = false;\n  private _decoder: UTF8Decoder | null = null;\n\n  constructor(\n    label: string = 'utf-8',\n    options: {\n      fatal?: boolean;\n      ignoreBOM?: boolean;\n    } = {}\n  ) {\n    if (options != null && typeof options !== 'object') {\n      throw new TypeError(\n        'Second argument of TextDecoder must be undefined or an object, e.g. { fatal: true }'\n      );\n    }\n\n    const normalizedLabel = String(label).trim().toLowerCase();\n    const encoding = getEncoding(normalizedLabel);\n    if (encoding === null || encoding.name === 'replacement') {\n      throw new RangeError(`Unknown encoding: ${label} (normalized: ${normalizedLabel})`);\n    }\n\n    if (!DECODERS[encoding.name]) {\n      throw new Error(`Decoder not present: ${encoding.name}`);\n    }\n\n    this._encoding = encoding;\n    this._ignoreBOM = !!options.ignoreBOM;\n    this._errorMode = options.fatal ? 'fatal' : 'replacement';\n  }\n\n  // Getter methods for encoding, fatal, and ignoreBOM\n  get encoding(): string {\n    return this._encoding?.name.toLowerCase() ?? '';\n  }\n\n  get fatal(): boolean {\n    return this._errorMode === 'fatal';\n  }\n\n  get ignoreBOM(): boolean {\n    return this._ignoreBOM;\n  }\n\n  decode(input?: ArrayBuffer | DataView, options: { stream?: boolean } = {}): string {\n    const bytes = normalizeBytes(input);\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._doNotFlush) {\n      this._decoder = DECODERS[this._encoding!.name]({\n        fatal: this.fatal,\n      });\n      this._BOMseen = false;\n    }\n\n    // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._doNotFlush = Boolean(options['stream']);\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    const input_stream = new Stream(bytes);\n\n    // 4. Let output be a new stream.\n    const output: number[] = [];\n\n    while (true) {\n      const token = input_stream.read();\n\n      if (token === END_OF_STREAM) break;\n\n      const result = this._decoder!.handler(input_stream, token);\n\n      if (result === FINISHED) break;\n\n      if (result !== null) {\n        output.push(result);\n      }\n    }\n\n    if (!this._doNotFlush) {\n      do {\n        const result = this._decoder!.handler(input_stream, input_stream.read());\n        if (result === FINISHED) break;\n        if (result === null) continue;\n        if (Array.isArray(result)) output.push(...result);\n        else output.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    return this.serializeStream(output);\n  }\n\n  // serializeStream method for converting code points to a string\n  private serializeStream(stream: number[]): string {\n    if (this._encoding!.name === 'UTF-8') {\n      if (!this._ignoreBOM && !this._BOMseen && stream[0] === 0xfeff) {\n        // If BOM is detected at the start of the stream and we're not ignoring it\n        this._BOMseen = true;\n        stream.shift(); // Remove the BOM\n      } else if (stream.length > 0) {\n        this._BOMseen = true;\n      }\n    }\n\n    // Convert the stream of code points to a string\n    return codePointsToString(stream);\n  }\n}\n"],"mappings":"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","ignoreList":[]}